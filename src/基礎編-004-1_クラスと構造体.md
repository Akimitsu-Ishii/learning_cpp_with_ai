## 質問
> では次のステップ（コードを部品化する：クラスと構造体）に移りましょう。

***
<h2><img src="image/KANAMI.png">

<font color="Maroon">KANAMI</font></h2>

オッケー！いよいよ本丸、クラスと構造体の話だね！ HPCの世界でも、計算の条件や結果をひとまとめにしたり、シミュレーションの各要素をオブジェクトとして表現したり、クラスの考え方はめちゃくちゃ役に立つから、しっかりマスターしていこう！

実はもう、スマートポインタの話の中で `Player` クラスや `MyData` クラスを使って、フライング気味に結構大事なところは話しちゃってるんだけど、ここでもう一度、しっかり体系的に整理していこうか！

### おさらい：クラスは「設計図」、オブジェクトは「実物」

* **クラス(Class):** 「プレイヤー」という概念の**設計図**。どんなデータ（HPや名前）を持っていて、どんなことができる（攻撃する、ステータス表示する）かを定義する。
* **オブジェクト(Object):** 設計図から作られた**実物**。`kanami` オブジェクトや `rookie` オブジェクトがこれにあたる。
* **カプセル化(Encapsulation):** `private`で大事なデータを隠して、`public`で公開した操作（メンバ関数）を通してのみアクセスを許す、安全のための仕組み。

ここまではOKだよね？

じゃあ、クラスを使いこなす上で絶対に知っておくべき、さらに進んだメカニズムを３つ紹介するよ！

### 1. イニシャライザリスト (Initializer List)

前に `Player` クラスのコンストラクタをこう書いたのを覚えてるかな？

```cpp
// 普通の書き方
Player(const std::string& name, int hp) {
    name_ = name;
    hp_ = hp;
}
```
これは、まず`name_`と`hp_`が空っぽの状態で生まれて、その直後にコンストラクタの`{}`の中で値が**代入**される、っていう動きになる。

でも、もっとプロフェッショナルで効率的な書き方があるんだ。それが**イニシャライザリスト**！

```cpp
// イニシャライザリストを使った書き方 (こっちがオススメ！)
Player(const std::string& name, int hp) : name_(name), hp_(hp) {
    // もう中身は空っぽでOK
}
```
コンストラクタの `()` の後ろにコロン `:` を付けて、そこでメンバ変数を初期化するんだ。`name_(name)` は、「メンバ変数 `name_` を、引数で受け取った `name` で**初期化**します」っていう意味。

「代入」より「初期化」の方が効率が良いし、`const`なメンバ変数や参照メンバ変数を初期化するには、この方法じゃないとダメ。**基本的にコンストラクタではイニシャライザリストを使う**って覚えておけば間違いないよ！

### 2. 自分自身を指すポインタ `this`

クラスのメンバ関数の中では、`this`っていう特別なキーワードが使えるんだ。これは、**「そのメンバ関数を呼び出しているオブジェクト自身を指すポインタ」** だよ。

例えば、`kanami.displayStatus()`が呼ばれているとき、`displayStatus()`の中では、`this`は`kanami`オブジェクトを指すポインタ (`Player*`型) になってる。

どんな時に使うかって？ 一番多いのは、引数名とメンバ変数名が被っちゃったときだね。

```cpp
class Player {
private:
    std::string name; // _ を付けないスタイルだと引数名と被る
    int hp;

public:
    Player(const std::string& name, int hp) : name(name), hp(hp) {
        // あれ、どっちがどっち？ コンパイラが混乱しちゃう！
    }
};
```
こんな時、`this`を使えば区別できる。

```cpp
// this を使って、メンバ変数であることを明示する
Player(const std::string& name, int hp) {
    this->name = name;
    this->hp = hp;
}
```
こうすれば、「このオブジェクトの`name`に、引数の`name`を代入する」って意味がハッキリするよね。（まあ、だから私は `name_` みたいに `_` を付けて区別するスタイルが好きなんだけどね！）

### 3. 「中身、変えません」宣言の `const`

メンバ関数の後ろに `const` を付けると、その関数が **「メンバ変数の値を一切変更しません」** という固い誓いになる。

```cpp
void displayStatus() const; // constを付ける！
```

`displayStatus()`は、ステータスを表示するだけで、HPを書き換えたりはしないよね。こういう関数には`const`を付けるべきなんだ。

**`const`を付けるメリット：**
1.  **安全:** `const`を付けた関数の中でうっかりメンバ変数を書き換えようとすると、コンパイラが「約束が違う！」ってエラーを出してくれる。
2.  **意思表示:** この関数が安全で読み取り専用であることが、一目でわかる。
3.  **`const`オブジェクトからも呼べる:** `const`で宣言されたオブジェクトは、`const`が付いたメンバ関数しか呼び出せない。

```cpp
// constオブジェクトとしてボスを定義
const Player boss("Dragon", 500);

boss.displayStatus(); // OK! displayStatusはconst関数だから

// boss.takeDamage(10); // コンパイルエラー！ takeDamageはconst関数じゃないから、
                      // constなbossオブジェクトには使えない
```

### まとめ

* クラスは、データと振る舞いをまとめた**設計図**。
* `private`でデータを守り、`public`で操作方法を公開する（**カプセル化**）。
* メンバ変数の初期化は**イニシャライザリスト**を使うのがプロ流。
* メンバ関数内では、自分自身を指すポインタ **`this`** が使える。
* 中身を書き換えないメンバ関数には、必ず **`const`** を付けて安全性を高める。

`struct`は、こういうカプセル化とかをあまり意識しない、単純なデータの入れ物として使うのが一般的だね。

さあ、これでクラスの基本的な骨格はほとんどマスターしたよ！ 次は、このクラスっていう設計図をさらに使いまわすための強力な仕組み、「継承」と「ポリモーフィズム」の世界に足を踏み入れてみようか！