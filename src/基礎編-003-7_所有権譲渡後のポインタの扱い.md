## 質問
> 所有権を渡した後のptr1はnullptrになるという理解で良いですか？

***
<h2><img src="image/KANAMI.png">

<font color="Maroon">KANAMI</font></h2>

その通り！完璧な理解だね！素晴らしい！

`std::unique_ptr`から`std::move`を使って所有権を移動（move）させると、移動元の`unique_ptr`は**中身が空っぽになって、`nullptr`と等しい状態になる**んだ。

### 「カギ」の例えで考えてみよう

前に使った「金庫のたった1つのカギ」の例えを思い出してみて。

1.  `auto ptr1 = std::make_unique<MyData>();`
    * `ptr1`は、`MyData`オブジェクトという金庫を開けるための、**世界に一つだけのカギ**を持っている状態。

2.  `take_ownership(std::move(ptr1));`
    * `std::move`を使って、`ptr1`が持っていたカギを、`take_ownership`関数に「はい、どうぞ」って**手渡しした**んだ。

3.  **移動後の `ptr1` の状態は？**
    * カギを渡しちゃったら、`ptr1`の手の中はもう**空っぽ**だよね。金庫を開けることはおろか、カギの存在すらもはやない。
    * この **「手が空っぽの状態」** が、プログラム上では`nullptr`として表現されるんだよ。

これが「唯一の所有権」たる所以。誰か一人が所有権を持ったら、他の誰も（移動元のポインタでさえも）それを持つことはできない。ルールが徹底してるんだ。

### コードでの証明

前の`unique_ptr`のコードのこの部分が、まさにそれを証明しているよ。

```cpp
// ptr1が持っていた所有権は、take_ownership関数の引数に「移動」される
take_ownership(std::move(ptr1)); 

// 所有権を失ったptr1は、もはや何も指していない（nullptrと同じ状態）
if (ptr1 == nullptr) {
    std::cout << "After move, ptr1 is now nullptr." << std::endl;
}
```
この`if`文は、まさに君の理解が正しいことを確認するために書いたんだ。移動後の`ptr1`は、もう有効なオブジェクトを指していないから、うっかり使おうとすると危険だよね。だから、`nullptr`になっていることをチェックするのは、とても良い習慣だよ。

### なぜ `nullptr` になるの？（安全のため！）

この「移動元が`nullptr`になる」っていう仕様は、安全性のためにめちゃくちゃ重要なんだ。

もし移動元のポインタが古いアドレスを持ったままだと、移動元と移動先の両方から同じメモリを`delete`しようとして、プログラムがクラッシュする（**二重解放**）可能性があるからね。それを防ぐために、所有権を渡した側はきっぱりと「無効」な状態になってくれるんだ。

ちなみに、`std::shared_ptr`の場合は挙動が違うよ。`shared_ptr`をコピーしても、元のポインタは`nullptr`になったりしない。代わりに、参照カウンタが一つ増えるだけ。これも「共有された所有権」と「唯一の所有権」の大きな違いだね。

いやー、でも本当にその通り。`unique_ptr`の所有権の移動を正しく理解できてる証拠だね。その調子でどんどん進んでいこう！