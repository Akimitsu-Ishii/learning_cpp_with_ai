# 基礎編2-5 参照（リファレンス）
> とりあえず動的メモリ確保までは何となく理解できました。
> 次は参照についてですかね？

***
## ![](./img/KANAMI.png "KANAMI") <font color="Maroon">KANAMI</font>

お、順調だね！動的メモリ確保のキモが分かれば、第一関門は突破したようなものだよ！

そう、次は**参照（リファレンス）** だね。ポインタとよく似てるけど、もっと安全で便利な場面も多い、C++の超重要機能だよ！ ポインタが「住所を書いた紙」だったのに対して、参照はもっと直接的な関係なんだ。

### 参照は、変数の「あだ名」

`int&`みたいに、型の後ろに`&`を付けて宣言するのが参照。これは、すでにある変数に **「あだ名」をつける**ようなものなんだ。

```cpp
#include <iostream>

int main() {
    int original = 100; // 本名「original」くん

    // int& で、original に対する参照（あだ名）「nickname」を宣言
    int& nickname = original; 
    
    std::cout << "本名: " << original << std::endl;
    std::cout << "あだ名: " << nickname << std::endl;

    std::cout << "\n--- あだ名の方を200に変えてみると… ---\n" << std::endl;
    
    nickname = 200; // あだ名を操作

    std::cout << "本名: " << original << std::endl;   // なんと本名の方も変わってる！
    std::cout << "あだ名: " << nickname << std::endl;

    return 0;
}
```
「nickname」は「original」の単なる別名だから、`nickname`を操作すると`original`そのものが変わる。`original`と`nickname`は、名前が違うだけで、指している実体は全く同じものなんだ。

### ポインタ vs 参照ガチンコ対決！

じゃあ、「住所を書いた紙」であるポインタと、「あだ名」である参照、何が違うの？って話だよね。これがすっごく大事！

| | ポインタ `int* p` | 参照 `int& r` | KANAMIの解説 |
| :--- | :--- | :--- | :--- |
| **正体** | 変数の**アドレスを格納する**独立した変数 | すでにある変数の**別名** | ポインタは「住所録」。参照は「あだ名」。全然違う！ |
| **初期化** | 宣言時に初期化しなくてもOK（危険！） | **宣言と同時に必ず初期化**が必要（安全！） | あだ名を付けるなら、誰のあだ名か最初から決めないとダメだよね。 |
| **再代入** | 指す相手を後から変えられる | 一度決めた相手を**後から変えられない** | 「田中くんのあだ名」を後から「鈴木くんのあだ名」に付け替えることはできない。 |
| **NULL** | `nullptr`（空）を指せる | `nullptr`に相当するものが**ない** | あだ名は実在する人にしか付けられない。だからヌルチェックが不要でコードがスッキリ！ |
| **使い方** | 値の操作に`*`が必要 (`*p = 10;`) | 普通の変数と**全く同じ** (`r = 10;`) | 見た目がシンプルで間違いにくい！これが参照の最大のメリットの一つ。 |

### 参照が最強に輝く場所：関数の引数

じゃあ、この「あだ名」が一番役に立つのはどこか？ それは**関数の引数**なんだ。
ある変数に関数の処理で変更を加えてもらいたい、っていう場面を考えてみよう。

```cpp
#include <iostream>

// 1. 値渡し (Pass-by-Value): コピーが作られるだけ。元の値は変わらない。
void func_value(int val) {
    val = 10;
}

// 2. ポインタ渡し (Pass-by-Pointer): アドレスを渡す。*で操作すれば元の値が変わる。
void func_pointer(int* p) {
    *p = 20; // *が必須
}

// 3. 参照渡し (Pass-by-Reference): あだ名を渡す。普通の変数みたいに操作すれば元の値が変わる。
void func_reference(int& ref) {
    ref = 30; // 見た目スッキリ！
}


int main() {
    int x = 0;
    std::cout << "Initial x = " << x << std::endl;

    func_value(x);
    std::cout << "After func_value: x = " << x << std::endl; // xは0のまま

    func_pointer(&x); // 呼び出すときに&でアドレスを渡す必要がある
    std::cout << "After func_pointer: x = " << x << std::endl; // xは20に変わる

    x = 0; // リセット
    func_reference(x); // 普通の変数を渡すように書ける！
    std::cout << "After func_reference: x = " << x << std::endl; // xは30に変わる

    return 0;
}
```

どう？ `func_reference`の使い方が、一番シンプルで分かりやすくない？
呼び出す側は`func_reference(x)`と自然に書けるし、関数の中も`ref = 30;`とスッキリ。でもちゃんと元の`x`の値を変更できてる。

### KANAMIからのアドバイス

* **関数に何かを渡すとき、そのデータが大きくてコピーしたくない、または関数内で変更したいなら、まず参照渡しを検討しよう！**
* **読み取り専用で、コピーだけ避けたいなら `const int&` のように `const` を付けた参照渡しが最強のテクニックだよ。**
* **ポインタは、「`nullptr`（何もない状態）」を表現する必要がある場合や、動的に確保したメモリを扱うときに使う。**

さあ、この参照を使いこなせば、君のC++コードはもっとエレガントで安全になる！ ポインタとの違い、しっかり体に叩き込んでね！
