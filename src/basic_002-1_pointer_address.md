# 基礎編2-1 ポインタとアドレス
> では早速ポインタとメモリ管理の学習に移ろうと思います。何か良い例題はありますか？

***
## ![](./img/KANAMI.png "KANAMI") <font color="Maroon">KANAMI</font>

お、いいね、その意気！ C++の最初の、そして最大の関門へようこそ！ ここを乗り越えれば、一気に世界が広がるから、気合入れていこう！

FortranやPythonにはなかったこの概念、最初は絶対につまずく。でも、HPCで性能を追求するなら避けては通れない道だからね。

いきなり複雑な問題をやるより、ステップを踏んで理解を深めるのがオススメだよ。私が考えた「ポインタと仲良くなるための3ステップ」に沿って例題を出してみるね！

---

### Step 1: 「アドレス」と「ポインタ」の基本を知る

まず、「ポインタ」って何？って話。それは **「メモリのアドレスを格納するための変数」** だよ。

よくある例えだけど、
* `int a = 10;` → `a`という名前の家に「10」という住人がいる
* `&a` → その`a`という家の**住所（アドレス）** を取得する
* `int* p;` → `p`という、**住所を書くための紙**（ポインタ変数）を用意する
* `p = &a;` → 紙`p`に、家`a`の住所を書き込む
* `*p` → 紙`p`に書かれた住所を頼りに、その家（`a`）に行って、住人（`10`）に会う（**間接参照**または**デリファレンス**という）

これを体験するための最初の例題だ！

**例題1：変数のアドレスを確認し、ポインタ経由でその値を読み書きしてみる**

```cpp
#include <iostream>

int main() {
    // 普通の整数型変数を宣言し、10で初期化
    int number = 10;

    // ポインタ変数を宣言。int型の変数を指すポインタなので int* と書く
    int* p_number;

    // 変数 number のアドレスを & で取得し、ポインタ p_number に代入
    p_number = &number;

    // -----------------------------------------------------------------
    // 確認してみよう！
    // -----------------------------------------------------------------

    // 1. 変数 number の値とアドレスを表示
    std::cout << "変数 number の ..." << std::endl;
    std::cout << "  値: " << number << std::endl;        // 普通に値を表示
    std::cout << "  アドレス: " << &number << std::endl;  // アドレスを表示

    std::cout << std::endl; // 見やすくするために改行

    // 2. ポインタ p_number 自体が持つ値（つまり number のアドレス）と、
    //    p_number が指し示す先の値（*p_number）を表示
    std::cout << "ポインタ p_number の ..." << std::endl;
    std::cout << "  保持しているアドレス: " << p_number << std::endl; // &number と同じアドレスが表示されるはず
    std::cout << "  指し示す先の値: " << *p_number << std::endl;     // number の値と同じ 10 が表示されるはず

    std::cout << "\n--- ポインタ経由で値を変更！ ---\n" << std::endl;

    // 3. ポインタを使って、変数 number の値を 25 に変更する
    *p_number = 25;

    // 4. number の値が本当に変わったか確認
    std::cout << "変更後の変数 number の値: " << number << std::endl; // 25 になってるかな？
    std::cout << "ポインタ経由で見た値: " << *p_number << std::endl; // もちろんこっちも 25 だね

    return 0;
}
```

まずはこのコードをじっくり読んで、何が起こっているか一行ずつ追ってみて！ ポインタが「アドレス」という値を持っていること、そして`*`を付けると「そのアドレスにある本体」にアクセスできること、この2つの感覚を掴むのが第一歩だよ。

---

### Step 2: 動的メモリ確保 `new` と解放 `delete`

Step 1は、すでにある変数を指し示すだけだった。でもポインタの真価は、**プログラム実行中に、好きなサイズのメモリを好きなタイミングで確保できる**ことにある。これを**動的メモリ確保**って言うんだ。

* `new`: 「このサイズのメモリちょうだい！」ってOSにお願いする。確保したメモリのアドレスを返してくれる。
* `delete`: 「このメモリ、もう使い終わったから返すね！」ってOSに通知する。

これをやらないと、Pythonのように自動でメモリを掃除してはくれない。**`new`したら、必ず自分で`delete`する！** これ、テストに出るよ。忘れると**メモリリーク**っていう、プログラムがどんどんメモリを食い潰していく最悪のバグになるからね。

**例題2: `new`で整数を1つ格納するメモリを確保し、使い終わったら`delete`する**

```cpp
#include <iostream>

int main() {
    // int型1つ分のメモリを動的に確保し、そのアドレスをポインタ p_dynamic に格納
    // 初期値として 777 を設定
    int* p_dynamic = new int(777);

    std::cout << "動的に確保したメモリ ..." << std::endl;
    std::cout << "  アドレス: " << p_dynamic << std::endl;
    std::cout << "  そこにある値: " << *p_dynamic << std::endl;

    // 値を書き換えてみる
    *p_dynamic = 999;
    std::cout << "  書き換えた後の値: " << *p_dynamic << std::endl;

    // --- ここが超重要！ ---
    // new で確保したメモリは、使い終わったら必ず delete で解放する
    delete p_dynamic;
    p_dynamic = nullptr; // 解放した後は、どこも指さないように nullptr を入れておくと安全（野良ポインタ防止）

    std::cout << "\nメモリを解放しました。" << std::endl;

    // 解放した後のポインタにアクセスするのは超危険！ (セグメンテーション違反などでクラッシュする原因)
    // std::cout << *p_dynamic << std::endl; // ← この行のコメントを外して実行するとどうなるかな？

    return 0;
}
```

---

### Step 3: ポインタと配列（HPCへの道）

さて、いよいよ本番だ。数値計算では、たくさんのデータを配列に格納するよね。プログラムを実行するまで配列のサイズが決まらないことも多い。そんな時こそ、動的メモリ確保の出番だ！

**例題3: 指定された個数の浮動小数点数（`double`型）の配列を動的に確保し、そこに乱数を格納して、その合計値を計算する**

```cpp
#include <iostream>
#include <cstdlib> // rand(), srand() を使うため
#include <ctime>   // time() を使うため

int main() {
    // ユーザーに配列のサイズを入力してもらう
    int size;
    std::cout << "配列のサイズを入力してください: ";
    std::cin >> size;

    // double型 `size` 個分の配列を動的に確保する
    // 配列を確保するときは new double[size] のように書く
    double* data_array = new double[size];

    // 乱数の初期化（毎回違う乱数が出るようにするおまじない）
    srand(static_cast<unsigned int>(time(nullptr)));

    // 配列に 0.0 から 1.0 の間の乱数を格納
    std::cout << "\n配列に乱数を格納します..." << std::endl;
    for (int i = 0; i < size; ++i) {
        // ポインタでも配列みたいに [i] でアクセスできる！
        data_array[i] = static_cast<double>(rand()) / RAND_MAX;
        std::cout << "data_array[" << i << "] = " << data_array[i] << std::endl;
    }

    // 合計値を計算
    double sum = 0.0;
    for (int i = 0; i < size; ++i) {
        sum += data_array[i];
    }

    std::cout << "\n合計値: " << sum << std::endl;

    // --- これも超重要！ ---
    // 配列を new[] で確保した場合は、delete[] で解放する
    delete[] data_array;
    data_array = nullptr;

    std::cout << "\n配列のメモリを解放しました。" << std::endl;

    return 0;
}
```
この例題3は、Fortranの`ALLOCATE`文で配列を確保するのとやりたいことは似てるけど、C++ではポインタを使って、より低レベルなメモリ管理を自分でやってる、って感じかな。

さあ、この3つのステップを、まずは自分の手でコンパイルして、動かしてみて！ そして、怖がらずに色々いじってみるのが上達への一番の近道だよ！
分からないところがあったら、すぐに聞くこと！いい？
