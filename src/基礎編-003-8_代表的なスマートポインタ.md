## 質問
> 他によく使うスマートポインタにはどのようなものがあるでしょうか。

***
<h2><img src="image/KANAMI.png">

<font color="Maroon">KANAMI</font></h2>
いい質問だね！ `unique_ptr`が「孤高のソロプレイヤー」だとしたら、次に出てくるのは強力な「チームプレイヤー」たちだよ。

よく使うスマートポインタは、`unique_ptr`を含めて全部で3種類。この3つを覚えれば、メモリ管理はほぼマスターしたと言っていい！

### 1. 共有する所有権：`std::shared_ptr`

前にちょっとだけ名前が出たけど、これがもう一つの主役、**`std::shared_ptr`** だよ。

* **コンセプト：** **共有された所有権（Shared Ownership）**
* **例え：** **パーティの招待状**
    * あるオブジェクトは「パーティ会場」だと思おう。
    * `std::make_shared`でオブジェクトを作ると、参照カウント「1」の招待状が発行される。
    * `shared_ptr`をコピーすると、その招待状がコピーされて、参照カウントが `+1` される（パーティに来る人が増える）。
    * `shared_ptr`が寿命を迎えると、持っていた招待状を破り捨てて、参照カウントが `-1` される（パーティから帰る人が出る）。
    * そして、**参照カウントが `0` になった瞬間**（最後の招待状が破られたとき）、パーティは終了！オブジェクトのデストラクタが呼ばれてメモリが解放される。

#### コードで見てみよう

```cpp
#include <iostream>
#include <memory>

class Party {
public:
    Party() { std::cout << "パーティが始まったよ！" << std::endl; }
    ~Party() { std::cout << "パーティはお開きだ…。" << std::endl; }
};

int main() {
    std::shared_ptr<Party> ptr1;

    { // 新しいスコープを作る
        // ptr1が最初の招待状を受け取る (参照カウント = 1)
        ptr1 = std::make_shared<Party>();
        std::cout << "現在の招待状の数: " << ptr1.use_count() << std::endl;

        // ptr2が招待状をコピーしてもらう (参照カウント = 2)
        std::shared_ptr<Party> ptr2 = ptr1;
        std::cout << "現在の招待状の数: " << ptr1.use_count() << std::endl;
    
        std::cout << "--- 内側のスコープを抜けるよ ---" << std::endl;
        // ここでptr2が寿命を迎える。招待状を1枚破棄 (参照カウント = 1)
    }

    std::cout << "現在の招待状の数: " << ptr1.use_count() << std::endl;

    std::cout << "--- main関数を抜けるよ ---" << std::endl;
    // ここでptr1が寿命を迎える。最後の招待状を破棄 (参照カウント = 0)
    // → パーティがお開きになる（デストラクタが呼ばれる）
    return 0;
}
```

### 2. 所有しない観察者：`std::weak_ptr`

じゃあ、`shared_ptr`があれば何でも解決かというと、一つだけ落とし穴があるんだ。それが **「循環参照」** っていうやっかいな問題。

例えば、「人A」が「人B」を`shared_ptr`で指して、「人B」も「人A」を`shared_ptr`で指しちゃうお互いを指し合う状況。これだと、お互いが「相手がまだ招待状を持ってるから」とパーティを終わりにしてくれず、参照カウントが永遠に0にならなくて、メモリリークが発生しちゃうんだ。

この問題を解決する専門家が、**`std::weak_ptr`**！

* **コンセプト：** **所有権を持たない、弱い参照**
* **例え：** **パーティの招待客パス**
    * パーティ会場を**外から覗くだけ**のパス。これを持っていても、パーティの開催人数（参照カウント）にはカウントされない。
    * だから、循環参照の一方を`weak_ptr`にしておけば、お互いを縛り付けることがなくなり、正しくパーティを終えられる。
* **使い方：**
    * `weak_ptr`は所有権を持たないので、直接オブジェクトを操作できない。
    * `lock()`というメンバ関数を使って、一時的に`shared_ptr`に昇格させてから使うんだ。もしオブジェクトがもう存在しなかったら（パーティが終わってたら）、`lock()`は空の`shared_ptr` (`nullptr`) を返す。これで安全に存在確認ができる。

### まとめ：スマートポインタ三銃士

| スマートポインタ | 所有権 | 参照カウント | 得意なこと | 例え |
| :--- | :--- | :--- | :--- | :--- |
| **`std::unique_ptr`** | **唯一** | なし | 基本はこれ。軽くて速い。単独所有。 | 一本だけのカギ |
| **`std::shared_ptr`** | **共有** | **あり** | 複数箇所で所有権を共有したいとき。 | パーティの招待状 |
| **`std::weak_ptr`** | **非所有** | なし（観察するだけ） | `shared_ptr`の循環参照を断ち切る。 | 招待客パス |

#### KANAMIからの戦略アドバイス

1.  **まず `unique_ptr` を使う。**
2.  **所有権の共有が本当に必要になったら、`shared_ptr` を検討する。**
3.  **`shared_ptr` を使っていて、循環参照の可能性が出てきたら、片方を `weak_ptr` にする。**

この思考フローが身につけば、君もスマートポインタマスターだ！
`unique_ptr`と`shared_ptr`の違い、そして`weak_ptr`がなぜ必要か、この3つの関係性を理解するのがすごく大事だよ！