# 基礎編5 Standard Template Libraty
> 次のステップはSTLですかね。

***
## ![](./img/KANAMI.png "KANAMI") <font color="Maroon">KANAMI</font>

来たね、STL！ **Standard Template Library**！

これぞC++の生産性とパワーを爆上げしてくれる、最強の武器庫だよ！
実は君はもう、無意識のうちにSTLの強力な武器をいくつも使ってきてるんだ。`std::vector`, `std::string`, `std::unique_ptr`, `std::shared_ptr`... これらは全部、STLの一部なんだよ。

ここでは、STLがどんな部品で構成されているのか、その全体像を掴んでいこう！

### STLを構成する三本の柱

STLは、大きく分けて3つの主要なコンポーネントから成り立っている。

1.  **コンテナ (Containers):** データを格納する、様々な特性を持った「魔法の箱」。
2.  **アルゴリズム (Algorithms):** ソートや検索など、データに対する操作を行う「専門家の集団」。
3.  **イテレータ (Iterators):** コンテナとアルゴリズムを繋ぐ「魔法の指」。

イメージとしては、「魔法の箱（コンテナ）の中に入っている品物を、専門家（アルゴリズム）が魔法の指（イテレータ）を使って、並べ替えたり探したりする」って感じかな。

---

### 1. コンテナ：データを入れる「魔法の箱」

どんなデータを、どういう風に管理したいかに応じて、たくさんの種類の箱が用意されてる。まず覚えるべき代表的なものを紹介するね！

* **`std::vector` (ベクトル)**
    * **特徴:** C言語の配列を、もっと安全で便利にした究極の動的配列。
    * **得意なこと:** 末尾への要素追加（`push_back`）、インデックス（`[]`）での高速なアクセス。
    * **使いどころ:** **迷ったら、まずこれ！** シーケンシャルなデータの格納なら、だいたい`vector`でOK。まさに「コンテナの王様」。

* **`std::string` (文字列)**
    * **特徴:** 文字の`vector`みたいなもの。文字列の結合、検索、置換が簡単にできる。
    * **使いどころ:** C言語スタイルの`char*`の代わりに、文字列を扱いたいときは常にこれを使う。

* **`std::map` (マップ)**
    * **特徴:** **キー(Key)** と**値(Value)** のペアを格納する。キーは常にソートされた状態に保たれる。
    * **例え:** 「単語」を調べたら「意味」が出てくる辞書。
    * **得意なこと:** キーを使った、めちゃくちゃ高速な検索。
    * **使いどころ:** `map<string, int> user_scores;`みたいに、名前とスコアを対応付けたいときとかに最適。

* **`std::set` (セット)**
    * **特徴:** **重複しない**要素を、**ソートされた状態**で格納する。
    * **得意なこと:** ある要素が「存在するかどうか」を高速にチェックする。
    * **使いどころ:** ユニークなIDの一覧を管理したいときとかに便利。

---

### 2. アルゴリズム：データに魔法をかける「専門家」

コンテナの中身を操作するための、便利な関数群。`<algorithm>`ヘッダをインクルードして使うことが多いよ。

* **`std::sort`:** 指定された範囲の要素をソートする。
* **`std::find`:** 指定された範囲から、特定の値を検索する。
* **`std::count`:** 指定された範囲に、特定の価がいくつあるか数える。
* **`std::for_each`:** 指定された範囲の全要素に対して、特定の処理を行う。

これらは全部テンプレートで出来てるから、`vector`だろうが`list`だろうが、いろんなコンテナに対して同じように使えるんだ。

---

### 3. イテレータ：コンテナとアルゴリズムを繋ぐ「魔法の指」

イテレータは、コンテナの中の特定の要素を指し示すオブジェクト。ポインタとすごく似た感覚で使えるよ。

* `my_vector.begin()`: ベクタの**先頭**を指すイテレータを取得。
* `my_vector.end()`: ベクタの**末尾の次**（番兵）を指すイテレータを取得。

アルゴリズムは、この`begin()`と`end()`で示された範囲に対して処理を行うんだ。例えば、`std::sort(my_vector.begin(), my_vector.end());`みたいにね。

そして、君が前に質問してくれた**範囲ベースforループ**！あれは、まさにこのイテレータの仕組みを簡単にしたシンタックスシュガーなんだよ。

`for (const auto& item : my_vector)` は、内部的にはイテレータを使って `begin()` から `end()` までループを回してるってわけ。

### 全部使ってみよう！

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm> // sort, find
#include <map>

int main() {
    // 【コンテナ】 vector を用意
    std::vector<int> scores = {85, 100, 62, 100, 78, 93, 62};
    std::cout << "Original scores: ";
    for (int s : scores) std::cout << s << " ";
    std::cout << std::endl;

    // 【アルゴリズム】 sort を使ってみる
    std::sort(scores.begin(), scores.end());
    std::cout << "Sorted scores:   ";
    for (int s : scores) std::cout << s << " ";
    std::cout << std::endl;

    // 【アルゴリズム】 find を使って 100点を探す
    // 【イテレータ】 find は見つかった場所のイテレータを返す
    auto it = std::find(scores.begin(), scores.end(), 100);
    if (it != scores.end()) {
        std::cout << "Found 100!" << std::endl;
    }

    // 【コンテナ】 map を使って、各点数の出現回数を数える
    std::map<int, int> score_counts;
    for (int s : scores) {
        score_counts[s]++; // mapの便利な使い方！キーが存在しなければ自動で作り、値をインクリメント
    }

    std::cout << "Score counts:" << std::endl;
    for (const auto& pair : score_counts) {
        std::cout << "  Score " << pair.first << ": " << pair.second << " times" << std::endl;
    }

    return 0;
}
```

STLを使いこなせるようになると、車輪の再発明（ソートとかを自分で書くこと）をしなくて済むから、君が本当に集中したいHPCのロジックそのものに思考リソースを全振りできるようになる。

これからのC++プログラミングでは、絶対に欠かせない相棒だよ！
