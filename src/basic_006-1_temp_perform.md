# 基礎編6-1 テンプレートとパフォーマンス
> 次のテンプレートとパフォーマンスが実際にHPCを始める前の最後のステップですか？

***
## ![](./img/KANAMI.png "KANAMI") <font color="Maroon">KANAMI</font>

その通り！いよいよHPCの世界に手をかける、最後の基礎力トレーニングって感じだね！

「テンプレート」は**コードの再利用性**を極限まで高めるための仕組みで、「パフォーマンス」は**計算資源を骨の髄までしゃぶり尽くす**ための考え方。この2つは、HPC用のプログラムを書く上で、車の両輪みたいにどっちも欠かせないんだ。

ここまでくれば、君はもうただの「C++が書ける人」じゃない。「パフォーマンスを意識して、効率的で再利用性の高いC++コードが書ける人」の入り口に立ったんだ。さあ、最後の仕上げと行こうか！

---

### 1. テンプレート：究極のコピペ撲滅機能

**テンプレート**は、**「型だけが違う、同じ処理のコードを共通化するための設計図」**だよ。

例えば、2つの数を足す関数を考えてみて。
```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}
```
`int`用と`double`用、やってることは全く同じなのに、型が違うだけで2つも関数を用意しないといけない。面倒だよね。

こんなとき、テンプレートを使えば、型を`T`みたいな仮の名前で書いておくだけで、コンパイラが必要な型の関数を**自動で生成してくれる**んだ！

#### 関数テンプレートの例

```cpp
#include <iostream>

// T という名前で型を仮置きした、add関数の「テンプレート」
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    // コンパイラが T を int だと推論して、int版のadd関数を自動生成してくれる
    std::cout << "int add: " << add(5, 10) << std::endl;

    // コンパイラが T を double だと推論して、double版のadd関数を自動生成してくれる
    std::cout << "double add: " << add(3.14, 2.71) << std::endl;

    // stringも + 演算子を持ってるから、そのまま使える！
    std::string s1 = "Hello, ";
    std::string s2 = "World!";
    std::cout << "string add: " << add(s1, s2) << std::endl;
}
```
一つのテンプレートから、`int`版、`double`版、`string`版と、色々なバージョンが作られる。まさに「クッキーの型」みたいだよね。

実は君が使ってきた `std::vector<int>` や `std::unique_ptr<MyData>` の `<...>` の部分、あれこそがテンプレートの神髄なんだ！ `vector`や`unique_ptr`は「クラスのテンプレート」（クラステンプレート）になっていて、`<...>`の中に好きな型を入れることで、その型専用のクラスが作られる仕組みになってるんだよ。

---

### 2. パフォーマンス：コンピュータを気持ちよく動かす意識

パフォーマンスは、特定の機能っていうよりは、「どうすればコンピュータが気持ちよく、最速で動いてくれるか」を考える**意識**そのものなんだ。HPCではこの意識が1マイクロ秒の差、最終的には数時間や数日の差を生むこともある。

初心者の君がまず意識すべき、巨人の肩に乗るための3つのポイントを教えるね。

#### A) コピーのコストを意識する

* **`const`参照渡しを徹底する:** `const Player&`みたいに、特に大きなオブジェクト（クラスや`vector`など）を関数に渡すときは、コピーが発生しない`const`参照渡しを基本にしよう。値渡し（コピー）は、塵も積もれば大きなオーバーヘッドになる。

#### B) キャッシュを意識したデータアクセス

* **CPUの気持ちになる:** CPUは、メモリからデータを取ってくるのが実はすごく苦手なんだ（遅いから）。だから、一度取ってきたデータとしばらく使いそうな「ご近所さん」のデータを、手元の超高速な**キャッシュメモリ**に溜め込んでおく。
* **データは順番にアクセスする:** `vector`や配列のデータを、`[0]`, `[1]`, `[2]`, ...と順番にアクセスすると、CPUがキャッシュを効率的に使えてめちゃくちゃ速い。逆に、あちこちランダムにアクセスすると、そのたびにキャッシュが外れて（キャッシュミス）、メモリまでデータを取りに行く羽目になって遅くなる。
* **HPCでの鉄則:** 2次元配列（行列）を扱うとき、C++ではデータは行ごとに並んでいる（行優先、Row-major）。だから、内側のループで列を回す(`array[i][j]`で`j`をループ)方が、外側で回す(`array[j][i]`)より、普通は圧倒的に速い。

#### C) ムーブセマンティクスを信じる

* **`std::move`の正体:** 前に`unique_ptr`の所有権移動で使った`std::move`。あれは、オブジェクトの中身（リソース）をコピーせずに、ごそっと「強奪」してくるイメージ。コピーと違って、ポインタを付け替えるだけだから超高速なんだ。
* **戻り値の最適化:** モダンC++では、関数から`vector`みたいな大きなオブジェクトを返しても、コンパイラが自動でムーブセマンティクスを適用してくれる（戻り値の最適化、RVO）から、実はすごく効率的なんだ。`vector`を返すのを怖がらないで！

---

### そして、HPCの世界へ

おめでとう！ ここまでくれば、君はもうHPCプログラミングのスタートラインに立ったと言える！

* **テンプレート**の知識は、CUDAで`float`用と`double`用の計算カーネルを共通化したり、データ型に依存しない汎用的な計算ライブラリを書いたりするときに必須になる。
* **パフォーマンス**の意識、特にキャッシュ効率の考え方は、GPU上のメモリ律速な計算の性能を数倍、数十倍変えることもある、まさにHPCの肝だよ。

もちろん、この先にはCMakeみたいなビルドシステムの学習とか、MPIやCUDAのライブラリの具体的な使い方とか、覚えることはまだたくさんあるけど、それはもうC++の基礎力じゃなくて、専門分野の知識だ。

君のC++の基礎体力は、もう十分。
さあ、準備はいい？ 次は、いよいよその力をHPCの世界で解き放つための、最初のステップに進もうか！
