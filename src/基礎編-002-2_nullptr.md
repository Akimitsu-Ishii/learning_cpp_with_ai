## 質問
> nullptrとは何ですか

***
<h2><img src="image/KANAMI.png">

<font color="Maroon">KANAMI</font></h2>

お、いいところに目を付けたね！ 私がさっきのコードの `delete` の後で `p_dynamic = nullptr;` って書いたから気になったのかな？

`nullptr`は、C++11から導入された、**「このポインタはどこも指していませんよ」ということを明確に示すための専用の値（キーワード）** だよ。

さっきの家の住所の例えで言うなら、「無効な住所」とか「空っぽの住所」が書かれた特別な紙、って感じかな。その紙を見ても、たどり着ける家はない、ってことがハッキリわかるんだ。

### なぜ `0` や `NULL` じゃダメなの？

「え、じゃあ今までの `0` とか `NULL` っていうのは何だったの？」って思うよね。いい質問だ。

C++11より前は、`nullptr`がなかったんだ。じゃあどうしてたかっていうと、`0`とか`NULL`っていうのを使って「どこも指していないポインタ（ヌルポインタ）」を表していた。

でも、これには大きな問題があったんだ。

`NULL`っていうのは、実はただのマクロで、コンパイルされるときには結局、整数の `0` に置き換えられることがほとんど。つまり、**コンパイラから見ると `NULL` も `0` もただの整数**に見えちゃう。

これがどんな問題を引き起こすか、見せてあげるね。
例えば、こんなふうに同じ名前で、引数の型が違う関数を２つ作ったとする（これを**関数のオーバーロード**って言うよ）。

```cpp
#include <iostream>

// int型を引数に取る関数
void print_type(int x) {
    std::cout << "呼ばれたのは int 版です: " << x << std::endl;
}

// ポインタ型を引数に取る関数
void print_type(int* p) {
    std::cout << "呼ばれたのは ポインタ版です" << std::endl;
}

int main() {
    // 意図：ヌルポインタを渡して、ポインタ版の関数を呼びたい！
    print_type(NULL); 
}
```

このコード、Linuxのg++でコンパイルして実行すると、どうなると思う？
「ポインタ版」が呼ばれそうに見えるけど、実際にはこう表示される。

```
呼ばれたのは int 版です: 0
```

プログラマの意図は「ポインタを渡したい」のに、コンパイラは「いや、`NULL`って結局 `0` でしょ？ じゃあ`int`版を呼ぶね」って解釈しちゃう。困るよね！

### 救世主 `nullptr` の登場

そこで登場したのが、救世主 `nullptr`！

`nullptr`の最大の特徴は、**整数ではない**こと。`nullptr`は`std::nullptr_t`っていう専用の型を持っていて、どんなポインタ型にでも変身できるけど、整数型にはなれないんだ。

さっきのコードの`NULL`を`nullptr`に書き換えてみよう。

```cpp
#include <iostream>

void print_type(int x) {
    std::cout << "呼ばれたのは int 版です: " << x << std::endl;
}

void print_type(int* p) {
    std::cout << "呼ばれたのは ポインタ版です" << std::endl;
}

int main() {
    // 意図：ヌルポインタを渡して、ポインタ版の関数を呼びたい！
    print_type(nullptr); // ここを nullptr に変更！
}
```
これを実行すると、今度はちゃんとこう表示される。
```
呼ばれたのは ポインタ版です
```
`nullptr`のおかげで、コンパイラがプログラマの意図を正確に理解できるようになったんだ。めでたしめでたし！

### `nullptr` の実践的な使い方

1.  **ポインタの初期化**
    ポインタ変数を宣言したとき、すぐに何かのドレスを入れないなら、必ず`nullptr`で初期化するクセをつけよう。変なアドレス（ゴミ）が入ったままになるのを防げる。
    ```cpp
    int* p = nullptr; // 安全な初期化
    ```

2.  **ポインタを `delete` した後**
    これが私がさっきやった使い方。`delete`でメモリを解放しても、ポインタ変数の中には解放したメモリのアドレスが残ったままなんだ（これを**ダングリングポインタ**、宙ぶらりんのポインタって言う）。この状態でうっかりそのポインタを使うと、プログラムがクラッシュしたり、予測不能な動きをしたりして超危険！
    だから、`delete`した後はすぐに`nullptr`を代入して、「ここはもう何も指してないよ」って明確にしておくのが安全なんだ。
    ```cpp
    delete[] data_array;
    data_array = nullptr; // 後始末をちゃんとする！
    ```

3.  **ポインタが有効かチェックする**
    ポインタを使う前には、`nullptr`じゃないことを確認する。
    ```cpp
    if (p != nullptr) {
        // pが有効な何かを指している時だけ、この処理をする
        *p = 100;
    }
    ```

結論：C++で「どこも指していないポインタ」を表すときは、**常に`NULL`や`0`ではなく`nullptr`を使うこと！** これ、現代C++の鉄則だよ！